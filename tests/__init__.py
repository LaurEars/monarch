import os
import sys
import errno
import shutil
import tempfile
import contextlib
from importlib import import_module

import nose


TEST_CONFIG = """
# monarch settings file, generated by monarch init
# feal free to edit it with your application specific settings

DATABASE = '{database_type}'

ENVIRONMENTS = {environments}

BACKUPS = {backups}

"""

def get_test_environment_string(port):
    return {
        'test': {
            'db_name': 'test_monarch',
            'host': 'localhost',
            'port': port
        },
        'from_test': {
            'db_name': 'from_monarch_test',
            'host': 'localhost',
            'port': port
        },
        'to_test': {
            'db_name': 'to_monarch_test',
            'host': 'localhost',
            'port': port
        },
    }


def get_backups_string(path_to_backups):
    return {
        'LOCAL': {
            'backup_dir': path_to_backups,
        },
    }


def get_config_string(port, database_type, path_to_backups='path_to_backups'):
    return TEST_CONFIG.format(
        database_type=database_type,
        environments=get_test_environment_string(port),
        backups=get_backups_string(path_to_backups)
    )


# [JT] TODO: would like to see these arguments as kwargs
def initialize_monarch(working_dir, port, database_type, backup_dir=None):
    migration_path = os.path.join(os.path.abspath(working_dir), 'migrations')
    create_migration_directory_if_necessary(migration_path)
    settings_file = os.path.join(os.path.abspath(working_dir), 'migrations/settings.py')
    with open(settings_file, 'w') as f:
        if backup_dir:
            f.write(get_config_string(port, database_type, backup_dir))
        else:
            f.write(get_config_string(port, database_type, backup_dir))

    m = import_module('migrations')
    reload(m)
    s = import_module('migrations.settings')
    reload(s)


def get_settings():
    s = import_module('migrations.settings')
    reload(s)
    return s


def no_op():
    pass


def create_migration_directory_if_necessary(dir):
    try:
        os.makedirs(dir)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise

    try:
        with open(os.path.join(os.path.abspath(dir), '__init__.py'), 'w') as f:
            f.write('# this file makes migrations a package')
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise


@contextlib.contextmanager
def isolated_filesystem_with_path():
    """A context manager that creates a temporary folder and changes
    the current working directory to it for isolated filesystem tests.

    The modification here is that it adds itself to the path

    """
    cwd = os.getcwd()
    t = tempfile.mkdtemp()
    os.chdir(t)
    sys.path.insert(1, t)
    try:
        yield t
    finally:
        os.chdir(cwd)
        sys.path.remove(t)
        try:
            shutil.rmtree(t)
        except (OSError, IOError):
            pass


if __name__ == "__main__":
    nose.run()
